<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Mini Fight (Hadouken)</title>
<style>
  body { margin:0; font-family: system-ui, -apple-system, "Hiragino Kaku Gothic ProN", sans-serif; background:#111; color:#fff; touch-action:none; }
  #ui { position:fixed; top:0; left:0; right:0; padding:10px; display:flex; gap:10px; align-items:center; z-index:10; background:linear-gradient(#111, rgba(17,17,17,.2)); }
  .bar { flex:1; height:14px; background:#333; border-radius:999px; overflow:hidden; }
  .bar > div { height:100%; width:100%; transition: width .08s linear, background .2s; }
  #msg { min-width:12em; text-align:center; font-weight:900; letter-spacing:.5px; }

  #arena { position:fixed; left:0; right:0; top:44px; bottom:150px; background:radial-gradient(circle at 50% 20%, #222, #0b0b0b 65%); overflow:hidden; }
  #ground { position:absolute; left:0; right:0; bottom:0; height:18px; background:#1f1f1f; box-shadow: 0 -1px 0 rgba(255,255,255,.05) inset; }

  .fighter{
  position:absolute; bottom:18px;
  width:64px; height:96px;

  /* å››è§’â†’äººå‹æ„Ÿï¼ˆèƒ´ä½“ï¼‰ */
  border-radius:18px 18px 14px 14px;
  box-shadow: 0 10px 25px rgba(0,0,0,.35);

  user-select:none;
  will-change:left, bottom, transform, filter;
  transition: filter .06s linear, transform .06s linear;

  /* ãƒ‘ãƒ¼ãƒ„ï¼ˆé ­ãƒ»è…•ãƒ»è¶³ï¼‰ã‚’æ“¬ä¼¼è¦ç´ ã§æã */
  overflow: visible;
}

/* é ­ï¼ˆä¸Šã«ã¡ã‚‡ã“ã‚“ã¨ä¸¸ï¼‰ */
.fighter::before{
  content:"";
  position:absolute;
  left:50%;
  top:-18px;
  width:42px; height:42px;
  transform: translateX(-50%);
  border-radius:999px;
  background: rgba(255,255,255,.14);
  box-shadow: 0 6px 14px rgba(0,0,0,.25);
}

/* è…•ï¼ˆå·¦å³ï¼‰ï¼‹ è¶³ï¼ˆä¸‹ï¼‰ã‚’1æšã§è¡¨ç¾ */
.fighter::after{
  content:"";
  position:absolute;
  left:50%;
  top:18px;
  width:88px; height:74px;
  transform: translateX(-50%);
  pointer-events:none;

  /* è…•2æœ¬ï¼‹è¶³2æœ¬ã‚’ã‚°ãƒ©ãƒ‡ã§æã */
  background:
    /* å·¦è…• */
    linear-gradient(rgba(255,255,255,.12), rgba(255,255,255,.12)) 0% 18% / 18px 42px no-repeat,
    /* å³è…• */
    linear-gradient(rgba(255,255,255,.12), rgba(255,255,255,.12)) 100% 18% / 18px 42px no-repeat,
    /* å·¦è¶³ */
    linear-gradient(rgba(0,0,0,.18), rgba(0,0,0,.18)) 38% 100% / 14px 18px no-repeat,
    /* å³è¶³ */
    linear-gradient(rgba(0,0,0,.18), rgba(0,0,0,.18)) 62% 100% / 14px 18px no-repeat;

  filter: drop-shadow(0 6px 10px rgba(0,0,0,.25));
}
  .face{
  position:absolute;
  left:10px; right:10px;
  top:22px;
  height:42px;
  border-radius:14px;
  background: linear-gradient(
    rgba(255,255,255,.14),
    rgba(255,255,255,.06)
  );
  box-shadow: inset 0 1px 0 rgba(255,255,255,.10);
  }

  /* ã‚¬ãƒ¼ãƒ‰ä¸­ã¯ã•ã‚‰ã«â€œæ§‹ãˆæ„Ÿâ€ */
.guarding::before{ background: rgba(255,255,255,.08); }
.guarding::after{
  /* è…•ã‚’å‰ã«å¯„ã›ã¦ã‚¬ãƒ¼ãƒ‰ã£ã½ã */
  background:
    linear-gradient(rgba(255,255,255,.16), rgba(255,255,255,.16)) 30% 18% / 18px 42px no-repeat,
    linear-gradient(rgba(255,255,255,.16), rgba(255,255,255,.16)) 70% 18% / 18px 42px no-repeat,
    linear-gradient(rgba(0,0,0,.18), rgba(0,0,0,.18)) 38% 100% / 14px 18px no-repeat,
    linear-gradient(rgba(0,0,0,.18), rgba(0,0,0,.18)) 62% 100% / 14px 18px no-repeat;
}

/* å¼±Pï¼šè…•ãŒã¡ã‚‡ã„å‰ï¼ˆçŸ­ã‚ï¼‰ */
.punching::after{
  background:
    linear-gradient(rgba(255,255,255,.20), rgba(255,255,255,.20)) 10% 18% / 24px 36px no-repeat,
    linear-gradient(rgba(255,255,255,.12), rgba(255,255,255,.12)) 100% 18% / 18px 42px no-repeat,
    linear-gradient(rgba(0,0,0,.18), rgba(0,0,0,.18)) 38% 100% / 14px 18px no-repeat,
    linear-gradient(rgba(0,0,0,.18), rgba(0,0,0,.18)) 62% 100% / 14px 18px no-repeat;
}

/* å¼·Kï¼šè¶³ãŒä¼¸ã³ãŸæ„Ÿï¼ˆä¸‹ã®æ£’ã‚’é•·ãï¼‰ */
.kicking::after{
  background:
    linear-gradient(rgba(255,255,255,.12), rgba(255,255,255,.12)) 0% 18% / 18px 42px no-repeat,
    linear-gradient(rgba(255,255,255,.12), rgba(255,255,255,.12)) 100% 18% / 18px 42px no-repeat,
    linear-gradient(rgba(0,0,0,.22), rgba(0,0,0,.22)) 32% 100% / 14px 26px no-repeat,
    linear-gradient(rgba(0,0,0,.22), rgba(0,0,0,.22)) 68% 100% / 14px 26px no-repeat;
}

/* æ³¢å‹•æ‹³ã®â€œç™ºå…‰æ„Ÿâ€ï¼ˆHADOUKEN!ã®ç¬é–“ã«punchingãŒä»˜ãã®ã§æ‹³ã£ã½ãå…‰ã‚‰ã›ã‚‹ï¼‰ */
.punching::before{
  box-shadow: 0 0 18px rgba(120,200,255,.55), 0 6px 14px rgba(0,0,0,.25);
}
  /* ãƒ’ãƒƒãƒˆãƒœãƒƒã‚¯ã‚¹ï¼šæ”»æ’ƒã®ç¨®é¡ã§ã‚µã‚¤ã‚ºãŒå¤‰ã‚ã‚‹ */
  .hitbox{
    position:absolute;
    bottom:26px;
    right:-10px;
    height:18px;
    border-radius:10px;
    opacity:0;
    pointer-events:none;
  }
  #p1.punching .hitbox{ width:40px; background:rgba(255,255,255,.28); opacity:1; }
  #p1.kicking  .hitbox{ width:72px; background:rgba(255,255,255,.18); opacity:1; }

  #cpu.punching .hitbox{ width:40px; background:rgba(255,255,255,.28); opacity:1; }
  #cpu.kicking  .hitbox{ width:72px; background:rgba(255,255,255,.18); opacity:1; }

  /* ã‚¬ãƒ¼ãƒ‰ä¸­ã®è¦‹ãŸç›® */
  .guarding{ filter: brightness(.65) saturate(.9); }

  /* æ³¢å‹•æ‹³ï¼ˆå¼¾ï¼‰ */
  .proj{
    position:absolute;
    width:18px; height:18px;
    border-radius:999px;
    background:rgba(120,200,255,.9);
    box-shadow: 0 0 14px rgba(120,200,255,.55);
    will-change:left, bottom;
  }

  #controls{
    position:fixed; left:0; right:0; bottom:0; height:150px;
    display:flex; gap:12px; padding:12px;
    background:linear-gradient(rgba(17,17,17,.2), #111);
    z-index:10;
  }
  .pad { flex:1.2; display:flex; gap:12px; }
  .rightPad { flex:1; display:flex; gap:12px; }
  button{
    flex:1;
    border:0; border-radius:18px;
    background:#2a2a2a; color:#fff;
    font-size:18px; font-weight:900;
    box-shadow: 0 10px 18px rgba(0,0,0,.35);
    -webkit-tap-highlight-color: transparent;
  }
  button:active{ transform: translateY(1px); filter:brightness(1.1); }
  #jump { background:#9b59b6; }
  #down { background:#16a085; }
  #punch { background:#f1c40f; color:#111; }
  #kick { background:#e67e22; }
  #restart { max-width:120px; }
  .tiny { font-size:12px; opacity:.85; font-weight:650; }
</style>
</head>
<body>
  <div id="ui">
    <div class="bar"><div id="hp1"></div></div>
    <div id="msg">FIGHT!</div>
    <div class="bar"><div id="hp2"></div></div>
  </div>

  <div id="arena">
    <div id="p1" class="fighter">
      <div class="name">YOU</div>
      <div class="face"></div>
      <div class="hitbox"></div>
    </div>
    <div id="cpu" class="fighter">
      <div class="name">CPU</div>
      <div class="face"></div>
      <div class="hitbox"></div>
    </div>
    <div id="ground"></div>
  </div>

  <div id="controls">
    <div class="pad">
      <button id="left">â†<div class="tiny">ç§»å‹•/ã‚¬ãƒ¼ãƒ‰</div></button>
      <button id="down">â†“<div class="tiny">ã‚³ãƒãƒ³ãƒ‰</div></button>
      <button id="right">â†’<div class="tiny">ç§»å‹•/ã‚¬ãƒ¼ãƒ‰</div></button>
    </div>

    <div class="rightPad">
      <button id="jump">â¬†ï¸<div class="tiny">ã‚¸ãƒ£ãƒ³ãƒ—</div></button>
      <button id="punch">ğŸ‘Š<div class="tiny">å¼±P / æ³¢å‹•</div></button>
      <button id="kick">ğŸ¦µ<div class="tiny">å¼·K</div></button>
      <button id="restart">â†»<div class="tiny">å†é–‹</div></button>
    </div>
  </div>

<script>
(() => {
  // ======= èª¿æ•´ãƒã‚¤ãƒ³ãƒˆ =======
  const MAX_HP = 100;
  const MOVE_SPEED = 5;

  // ã‚¸ãƒ£ãƒ³ãƒ—
  const JUMP_V = 14;
  const GRAVITY = 0.75;
  const LAND_LAG_MS = 150;

  // CPU
  const CPU_THINK_MS = 160;

  // ã‚¬ãƒ¼ãƒ‰
  const GUARD_MULT = 0.33;
  const GUARD_PUSH_MULT = 0.35;
  const GUARD_HITSTOP_MS = 60;

  // æ”»æ’ƒ2ç¨®
  const ATTACKS = {
    punch: { label:'PUNCH', dmg: 7,  range: 52, activeMs: 90,  recoveryMs: 140, cooldownMs: 220, push: 8 },
    kick:  { label:'KICK',  dmg: 13, range: 78, activeMs: 130, recoveryMs: 260, cooldownMs: 420, push: 12 }
  };

  // æ³¢å‹•æ‹³
  const HADOU = {
    dmg: 11,
    speed: 7.2,           // å¼¾ã®é€Ÿåº¦
    y: 46,                // åœ°é¢ã‹ã‚‰ã®é«˜ã•
    radius: 9,            // å½“ãŸã‚Šåˆ¤å®šåŠå¾„
    cooldownMs: 700,
    recoveryMs: 220,
    inputWindowMs: 600    // â†“â†’ ã®çŒ¶äºˆ
  };
  // ============================

  const arena = document.getElementById('arena');
  const p1El = document.getElementById('p1');
  const cpuEl = document.getElementById('cpu');
  const hp1El = document.getElementById('hp1');
  const hp2El = document.getElementById('hp2');
  const msgEl = document.getElementById('msg');

  const btnL = document.getElementById('left');
  const btnD = document.getElementById('down');
  const btnR = document.getElementById('right');
  const btnJ = document.getElementById('jump');
  const btnP = document.getElementById('punch');
  const btnK = document.getElementById('kick');
  const btnRe = document.getElementById('restart');

  const state = {
    running: true,
    p1: {
      x:0, y:0, vy:0,
      lockUntil:0,
      hp:MAX_HP,
      lastAtkAt:{punch:0,kick:0},
      guarding:false,
      lastHadouAt: 0,
      inputSeq: [] // {k:'D'|'R', t:ms}
    },
    cpu:{
      x:0,
      hp:MAX_HP,
      lastAtkAt:{punch:0,kick:0}
    },
    input:{ left:false, right:false, down:false },
    lastCpuThink: 0,
    projectiles: [] // {x, vx, el}
  };

  const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));
  const nowMs = ()=>performance.now();
  const setMsg = (t)=>{ msgEl.textContent = t; };

  function hpColor(hp){
    const r = hp / MAX_HP;
    if (r > 0.6) return '#2ecc71';
    if (r > 0.3) return '#f1c40f';
    return '#e74c3c';
  }

  function distance(){
    return Math.abs((state.p1.x + 32) - (state.cpu.x + 32));
  }

  function layoutInit(){
    const w = arena.clientWidth;
    state.p1.x = w * 0.20;
    state.cpu.x = w * 0.70;
    render();
  }

  function render(){
    p1El.style.left = `${state.p1.x}px`;
    cpuEl.style.left = `${state.cpu.x}px`;

    p1El.style.bottom = `${18 + state.p1.y}px`;
    cpuEl.style.bottom = `18px`;

    hp1El.style.width = `${(state.p1.hp / MAX_HP) * 100}%`;
    hp2El.style.width = `${(state.cpu.hp / MAX_HP) * 100}%`;
    hp1El.style.background = hpColor(state.p1.hp);
    hp2El.style.background = hpColor(state.cpu.hp);

    p1El.classList.toggle('guarding', state.p1.guarding);

    // å¼¾ã®æç”»
    for (const p of state.projectiles) {
      p.el.style.left = `${p.x}px`;
      p.el.style.bottom = `${18 + HADOU.y}px`;
    }
  }

  function endIfDead(){
    if (state.p1.hp <= 0) { state.running = false; setMsg('CPU WIN!'); return true; }
    if (state.cpu.hp <= 0){ state.running = false; setMsg('YOU WIN!'); return true; }
    return false;
  }

  function bindTap(btn, fn){
    const handler = (e) => { e.preventDefault?.(); fn(); };
    btn.addEventListener('pointerdown', handler, { passive:false });
    btn.addEventListener('touchstart', handler, { passive:false });
    btn.addEventListener('mousedown', handler);
    btn.addEventListener('click', (e)=>{ e.preventDefault(); fn(); });
  }

  function bindHold(btn, key){
    const on  = (e)=>{ e.preventDefault?.(); state.input[key]=true; onInputKey(key); };
    const off = (e)=>{ e.preventDefault?.(); state.input[key]=false; };
    btn.addEventListener('pointerdown', on, { passive:false });
    btn.addEventListener('touchstart', on, { passive:false });
    btn.addEventListener('mousedown', on);
    btn.addEventListener('pointerup', off);
    btn.addEventListener('pointercancel', off);
    btn.addEventListener('pointerleave', off);
    btn.addEventListener('touchend', off);
    btn.addEventListener('touchcancel', off);
    btn.addEventListener('mouseup', off);
    btn.addEventListener('mouseleave', off);
  }

  function setP1Lock(t, ms){
    state.p1.lockUntil = Math.max(state.p1.lockUntil, t + ms);
  }

  function canUseAttack(who, type, t){
    return (t - who.lastAtkAt[type]) >= ATTACKS[type].cooldownMs;
  }

  function showAttackAnim(el, type, ms){
    el.classList.remove('punching','kicking');
    el.classList.add(type === 'punch' ? 'punching' : 'kicking');
    setTimeout(()=>el.classList.remove('punching','kicking'), ms);
  }

  function isP1GuardInput(){
    if (state.p1.y > 0) return false;
    const cpuOnRight = state.cpu.x >= state.p1.x;
    const backHeld = cpuOnRight ? state.input.left : state.input.right;
    return !!backHeld;
  }

  function doJump(){
    const t = nowMs();
    if (!state.running) return;
    if (t < state.p1.lockUntil) return;
    if (state.p1.y === 0) {
      state.p1.vy = JUMP_V;
      setMsg('JUMP!');
    }
  }

  // ---- ã‚³ãƒãƒ³ãƒ‰å…¥åŠ›ï¼ˆâ†“â†’ï¼‰ ----
  function onInputKey(key){
    const t = nowMs();
    const k = (key === 'down') ? 'D' : (key === 'right' ? 'R' : (key === 'left' ? 'L' : '?'));
    if (k === '?') return;

    // æœ€ä½é™ï¼šâ†“â†’ã ã‘æ‹¾ã†ã€‚å·¦ã¯ä»Šã¯ä½¿ã‚ãªã„
    if (k === 'D' || k === 'R') {
      state.p1.inputSeq.push({k, t});
      // å¤ã„ã®æ¨ã¦ã‚‹
      state.p1.inputSeq = state.p1.inputSeq.filter(x => (t - x.t) <= HADOU.inputWindowMs);
    }
  }

  function hadouCommandReady(){
  const t = nowMs();
  // ç›´è¿‘inputWindowMsä»¥å†…ã®å…¥åŠ›ã ã‘æ®‹ã™
  state.p1.inputSeq = state.p1.inputSeq.filter(x => (t - x.t) <= HADOU.inputWindowMs);

  // ã€Œâ†“ã‚’æœ€è¿‘æŠ¼ã—ãŸã€åˆ¤å®š
  const recentDown = state.p1.inputSeq.some(x => x.k === 'D');

  // ã€Œã„ã¾â†’ãŒæŠ¼ã•ã‚Œã¦ã‚‹ã€åˆ¤å®šï¼ˆæŠ¼ã—ã£ã±OKï¼‰
  const rightHeld = !!state.input.right;

  return recentDown && rightHeld;
  }

  function clearHadouSeq(){
    state.p1.inputSeq.length = 0;
  }
  // ----------------------------

  function spawnHadouken(){
    const t = nowMs();
    if (!state.running) return;
    if (state.p1.y > 0) { setMsg('AIR'); return; }
    if (t < state.p1.lockUntil) return;
    if ((t - state.p1.lastHadouAt) < HADOU.cooldownMs) return;

    state.p1.lastHadouAt = t;
    setP1Lock(t, HADOU.recoveryMs);

    const el = document.createElement('div');
    el.className = 'proj';
    arena.appendChild(el);

    // å¼¾ã®åˆæœŸä½ç½®ï¼šYOUã®å‰ã‚ãŸã‚Š
    const startX = state.p1.x + 64; // å³æ–¹å‘ç™ºå°„ï¼ˆä»Šå›ã¯å›ºå®šã§OKï¼‰
    state.projectiles.push({ x: startX, vx: HADOU.speed, el });

    setMsg('HADOUKEN!');
    clearHadouSeq();
  }

  function doAttackP1(type){
    const t = nowMs();
    if (!state.running) return;
    if (state.p1.y > 0) { setMsg('AIR'); return; }
    if (t < state.p1.lockUntil) return;

    // ğŸ‘ŠæŠ¼ã—ãŸç¬é–“ã€â†“â†’ãŒæˆç«‹ã—ã¦ãŸã‚‰æ³¢å‹•æ‹³ã‚’å„ªå…ˆ
    if (type === 'punch' && hadouCommandReady()) {
      spawnHadouken();
      render();
      return;
    }

    if (!canUseAttack(state.p1, type, t)) return;

    const spec = ATTACKS[type];
    state.p1.lastAtkAt[type] = t;

    showAttackAnim(p1El, type, spec.activeMs);
    setP1Lock(t, spec.recoveryMs);

    if (distance() <= spec.range) {
      state.cpu.hp = clamp(state.cpu.hp - spec.dmg, 0, MAX_HP);
      setMsg(`${spec.label}! HIT`);
      state.cpu.x = clamp(state.cpu.x + (-spec.push), 0, arena.clientWidth - 64);
    } else {
      setMsg(`${spec.label}! MISS`);
    }

    endIfDead();
    render();
  }

  function applyHitToP1(dmg, push){
    const t = nowMs();
    const guarding = state.p1.guarding && isP1GuardInput();

    if (guarding) {
      const gdmg = Math.max(1, Math.floor(dmg * GUARD_MULT));
      state.p1.hp = clamp(state.p1.hp - gdmg, 0, MAX_HP);
      setMsg('GUARD!');
      const gpush = Math.round(push * GUARD_PUSH_MULT);
      state.p1.x = clamp(state.p1.x + gpush, 0, arena.clientWidth - 64);
      setP1Lock(t, GUARD_HITSTOP_MS);
      return;
    }

    state.p1.hp = clamp(state.p1.hp - dmg, 0, MAX_HP);
    setMsg('HIT!');
    state.p1.x = clamp(state.p1.x + push, 0, arena.clientWidth - 64);
    setP1Lock(t, 90);
  }

  function doAttackCPU(type){
    const t = nowMs();
    if (!state.running) return;
    if (!canUseAttack(state.cpu, type, t)) return;

    const spec = ATTACKS[type];
    state.cpu.lastAtkAt[type] = t;

    showAttackAnim(cpuEl, type, spec.activeMs);

    if (distance() <= spec.range) {
      applyHitToP1(spec.dmg, spec.push);
    } else {
      setMsg(`CPU ${spec.label} MISS`);
    }

    endIfDead();
    render();
  }

  function cpuThink(){
    const d = distance();
    const toward = (state.p1.x > state.cpu.x) ? 1 : -1;

    if (d > 120) {
      state.cpu.x += toward * MOVE_SPEED * 0.85;
    } else {
      const r = Math.random();
      if (d <= ATTACKS.kick.range && r < 0.55) doAttackCPU('kick');
      else doAttackCPU('punch');

      if (Math.random() < 0.22) state.cpu.x -= toward * MOVE_SPEED * 0.7;
    }
    state.cpu.x = clamp(state.cpu.x, 0, arena.clientWidth - 64);
  }

  function updateProjectiles(){
    // å¼¾ç§»å‹•ï¼‹å½“ãŸã‚Šåˆ¤å®š
    const w = arena.clientWidth;

    for (let i = state.projectiles.length - 1; i >= 0; i--) {
      const p = state.projectiles[i];
      p.x += p.vx;

      // å½“ãŸã‚Šåˆ¤å®šï¼ˆå¼¾ä¸­å¿ƒ vs CPUä¸­å¿ƒï¼‰
      const px = p.x + HADOU.radius;
      const cx = state.cpu.x + 32;
      const hit = Math.abs(px - cx) <= (HADOU.radius + 20); // ã–ã£ãã‚Š

      if (hit) {
        state.cpu.hp = clamp(state.cpu.hp - HADOU.dmg, 0, MAX_HP);
        setMsg('HADOU HIT!');
        // ã¡ã‚‡ã„ãƒãƒƒã‚¯ãƒãƒƒã‚¯
        state.cpu.x = clamp(state.cpu.x - 10, 0, w - 64);

        // æ¶ˆã™
        p.el.remove();
        state.projectiles.splice(i, 1);

        endIfDead();
        continue;
      }

      // ç”»é¢å¤–ã§æ¶ˆã™
      if (p.x > w + 40) {
        p.el.remove();
        state.projectiles.splice(i, 1);
      }
    }
  }

  function reset(){
    state.running = true;
    state.p1.hp = MAX_HP;
    state.cpu.hp = MAX_HP;

    state.p1.y = 0;
    state.p1.vy = 0;
    state.p1.lockUntil = 0;
    state.p1.guarding = false;
    state.p1.lastHadouAt = 0;
    state.p1.inputSeq.length = 0;

    state.p1.lastAtkAt.punch = 0;
    state.p1.lastAtkAt.kick = 0;
    state.cpu.lastAtkAt.punch = 0;
    state.cpu.lastAtkAt.kick = 0;

    state.input.left = false;
    state.input.right = false;
    state.input.down = false;

    // å¼¾æ¶ˆã™
    for (const p of state.projectiles) p.el.remove();
    state.projectiles.length = 0;

    setMsg('FIGHT!');
    layoutInit();
  }

  // å…¥åŠ›
  bindHold(btnL, 'left');
  bindHold(btnD, 'down');
  bindHold(btnR, 'right');

  bindTap(btnJ, () => doJump());
  bindTap(btnP, () => doAttackP1('punch')); // â†“â†’ + ğŸ‘Š ã§æ³¢å‹•æ‹³
  bindTap(btnK, () => doAttackP1('kick'));
  bindTap(btnRe, () => reset());

  // ãƒ«ãƒ¼ãƒ—
  function tick(t){
    if (state.running) {
      // ã‚¬ãƒ¼ãƒ‰
      state.p1.guarding = isP1GuardInput();

      // ã‚¸ãƒ£ãƒ³ãƒ—ç‰©ç†
      if (state.p1.y > 0 || state.p1.vy > 0) {
        state.p1.y += state.p1.vy;
        state.p1.vy -= GRAVITY;
        if (state.p1.y <= 0) {
          state.p1.y = 0;
          state.p1.vy = 0;
          setP1Lock(t, LAND_LAG_MS);
          setMsg('LAND');
        }
      }

      // ç§»å‹•ï¼ˆç¡¬ç›´ä¸­ã¯ä¸å¯ï¼‰
      if (t >= state.p1.lockUntil) {
        if (state.input.left)  state.p1.x -= MOVE_SPEED;
        if (state.input.right) state.p1.x += MOVE_SPEED;
      }
      state.p1.x = clamp(state.p1.x, 0, arena.clientWidth - 64);

      // å¼¾
      updateProjectiles();

      // CPU
      if (t - state.lastCpuThink > CPU_THINK_MS) {
        state.lastCpuThink = t;
        cpuThink();
      }
    }

    render();
    requestAnimationFrame(tick);
  }

  window.addEventListener('resize', layoutInit);
  layoutInit();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
